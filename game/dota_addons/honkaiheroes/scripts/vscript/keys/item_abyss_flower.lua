LinkLuaModifier( "modifier_black_abyss", "keys/item_abyss_flower", LUA_MODIFIER_MOTION_NONE )LinkLuaModifier( "modifier_black_abyss_passive", "keys/item_abyss_flower", LUA_MODIFIER_MOTION_NONE )LinkLuaModifier( "modifier_black_abyss_wound", "keys/item_abyss_flower", LUA_MODIFIER_MOTION_NONE )LinkLuaModifier( "modifier_white_flower", "keys/item_abyss_flower", LUA_MODIFIER_MOTION_NONE )LinkLuaModifier( "modifier_white_flower_passive", "keys/item_abyss_flower", LUA_MODIFIER_MOTION_NONE )LinkLuaModifier( "modifier_white_flower_buff", "keys/item_abyss_flower", LUA_MODIFIER_MOTION_NONE )item_white_flower = class({})item_black_abyss = class({})--BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS----BLACK--ABYSS--function item_black_abyss:OnSpellStart()	local caster = self:GetCaster()	local point = self:GetCursorPosition()	if self:GetCursorTarget() == caster then		local flower = nil		self:EndCooldown()		for i=0,8 do			local item = caster:GetItemInSlot(i)			if item and item:GetAbilityName()  == "item_white_flower"  then				caster:RemoveItem(self)				caster:RemoveItem(item)				caster:AddItemByName("item_key_of_creation")				return			end		end		return	end	local honka = caster:FindModifierByName("modifier_honkai_penalti")	local honkaEnt = honka:GetCaster()	local cTarget = self:GetCursorTarget()		local vector = self:GetCursorPosition() - caster:GetOrigin()	local projectile_speed = self:GetSpecialValueFor( "projectile_speed" )	local projectile_distance = vector:Length2D()	local projectile_direction = vector	projectile_direction.z = 0	projectile_direction = projectile_direction:Normalized()	-- create projectile	local info = {		Source = caster,		Ability = self,		vSpawnOrigin = caster:GetAbsOrigin(),			    iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_NONE,	    iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,	    iUnitTargetType = DOTA_UNIT_TARGET_NONE,	    fDistance = projectile_distance,	    fStartRadius = 0,	    fEndRadius = 0,		vVelocity = projectile_direction * projectile_speed,		EffectName = "particles/econ/items/drow/drow_arcana/drow_arcana_multishot_linear_proj_base.vpcf"	}	ProjectileManager:CreateLinearProjectile(info)	caster:AddNewModifier(		honkaEnt,		honka:GetAbility(),		"modifier_honkai_debuff",		{extra_stack = self:GetSpecialValueFor("apply_stacks")})	return trueendfunction item_black_abyss:OnProjectileHit( target, location )	if target then return false end		local duration = self:GetSpecialValueFor( "duration" )	local caster = self:GetCaster()	local radius = self:GetSpecialValueFor( "radius" )	local damage = self:GetSpecialValueFor( "damage" )	local enemies = FindUnitsInRadius(		caster:GetTeamNumber(),	-- int, your team number		location,	-- point, center point		nil,	-- handle, cacheUnit. (not known)		radius,	-- float, radius. or use FIND_UNITS_EVERYWHERE		DOTA_UNIT_TARGET_TEAM_ENEMY,	-- int, team filter		DOTA_UNIT_TARGET_HERO + DOTA_UNIT_TARGET_BASIC,	-- int, type filter		DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES, 	-- int, flag filter		0,	-- int, order filter		false	-- bool, can grow cache	)	local damageTable = {		attacker = caster,		damage_type = DAMAGE_TYPE_PURE,		ability = self, --Optional.		damage = caster:GetAttackDamage()*damage/100	}	for _,mate in pairs(enemies) do		damageTable.victim = mate		ApplyDamage(damageTable)		mate:AddNewModifier(caster, self, "modifier_black_abyss", {duration = duration})		SendOverheadEventMessage(nil, OVERHEAD_ALERT_BONUS_POISON_DAMAGE  , mate, caster:GetAttackDamage()*damage/100, caster:GetPlayerOwner())	end	self:PlayEffects(location)endfunction item_black_abyss:PlayEffects(location)	-- Get Resources	local particle_cast = "particles/units/heroes/hero_dark_willow/dark_willow_wisp_spell_ring.vpcf"	local sound_cast = "Honkaiheroes.Skadi.Cast2"	-- -- Create Particle	local effect_cast = ParticleManager:CreateParticle( particle_cast, PATTACH_WORLDORIGIN, self:GetCaster() )	ParticleManager:SetParticleControl( effect_cast, 0, location )	ParticleManager:SetParticleControl( effect_cast, 1, Vector( self:GetSpecialValueFor( "radius" ),0,0) )	ParticleManager:ReleaseParticleIndex( effect_cast )	-- Create Sound	EmitSoundOnLocationWithCaster( self:GetParent():GetOrigin(), sound_cast, self:GetCaster() )endfunction item_black_abyss:GetIntrinsicModifierName()	return "modifier_black_abyss_passive"	endmodifier_black_abyss_passive = class({})function modifier_black_abyss_passive:IsHidden() return true endfunction modifier_black_abyss_passive:OnCreated()	self.damage_convert = self:GetAbility():GetSpecialValueFor("damage_convert")/100endfunction modifier_black_abyss_passive:GetModifierProcAttack_Feedback(event)	if event.damage_category == 1 then		--event.target:AddNewModifier(event.attacker, self:GetAbility(), "modifier_black_abyss_wound", {damage = event.damage*self.damage_convert})	end	return 0endfunction modifier_black_abyss_passive:DeclareFunctions()	return {	--MODIFIER_PROPERTY_PROCATTACK_FEEDBACK 	}endfunction modifier_black_abyss_passive:GetModifierBonusStat_BurstmodeDamage()	return self:GetAbility():GetSpecialValueFor("burst_buff")endmodifier_black_abyss = class({})function modifier_black_abyss:IsPurgable() return false endfunction modifier_black_abyss:DeclareFunctions()	return {MODIFIER_PROPERTY_DISABLE_HEALING }endfunction modifier_black_abyss:GetDisableHealing()	return 1endmodifier_black_abyss_wound = class({})function modifier_black_abyss_wound:OnCreated(event)	if not IsServer() then return end	self:SetStackCount(event.damage)endfunction modifier_black_abyss_wound:OnRefresh(event)	if not event.damage then return end	self:SetStackCount(self:GetStackCount()+4)	self:GetParent():CalculateGenericBonuses()endfunction modifier_black_abyss_wound:GetModifierHealthBonus()	return -self:GetStackCount()endfunction modifier_black_abyss_wound:DeclareFunctions()	return {		MODIFIER_PROPERTY_HEALTH_BONUS  	}end--WHITE--FLOWER----WHITE--FLOWER----WHITE--FLOWER----WHITE--FLOWER----WHITE--FLOWER----WHITE--FLOWER----WHITE--FLOWER----WHITE--FLOWER--function item_white_flower:GetIntrinsicModifierName() return "modifier_white_flower_passive"	endfunction item_white_flower:CastFilterResult()	return UF_SUCCESS endfunction item_white_flower:OnSpellStart()	if not IsServer()  then return true end	local caster = self:GetCaster()	local point = self:GetCursorPosition()	if self:GetCursorTarget() == caster then		local flower = nil		self:EndCooldown()		for i=0,8 do			local item = caster:GetItemInSlot(i)			if item and item:GetAbilityName()  == "item_black_abyss"  then				caster:RemoveItem(self)				caster:RemoveItem(item)				caster:AddItemByName("item_key_of_creation")				return true			end		end				return false	end	local honka = caster:FindModifierByName("modifier_honkai_penalti")	local honkaEnt = honka:GetCaster()	local cTarget = self:GetCursorTarget()		local vector = self:GetCursorPosition() - caster:GetOrigin()	local projectile_speed = self:GetSpecialValueFor( "projectile_speed" )	local projectile_distance = vector:Length2D()	local projectile_direction = vector	projectile_direction.z = 0	projectile_direction = projectile_direction:Normalized()	-- create projectile	local info = {		Source = caster,		Ability = self,		vSpawnOrigin = caster:GetAbsOrigin(),			    iUnitTargetTeam = DOTA_UNIT_TARGET_TEAM_NONE,	    iUnitTargetFlags = DOTA_UNIT_TARGET_FLAG_NONE,	    iUnitTargetType = DOTA_UNIT_TARGET_NONE,	    fDistance = projectile_distance,	    fStartRadius = 0,	    fEndRadius = 0,		vVelocity = projectile_direction * projectile_speed,		EffectName = "particles/econ/items/drow/drow_arcana/drow_arcana_multishot_linear_proj_base.vpcf"	}	ProjectileManager:CreateLinearProjectile(info)	caster:AddNewModifier(		honkaEnt,		honka:GetAbility(),		"modifier_honkai_debuff",		{extra_stack = self:GetSpecialValueFor("apply_stacks")})	return trueendfunction item_white_flower:OnProjectileHit( target, location )	if target then return false end		local duration = self:GetSpecialValueFor( "duration" )	local caster = self:GetCaster()	local radius = self:GetSpecialValueFor( "radius" )	local heal = self:GetSpecialValueFor( "heal" )	local teammates = FindUnitsInRadius(		caster:GetTeamNumber(),	-- int, your team number		location,	-- point, center point		nil,	-- handle, cacheUnit. (not known)		radius,	-- float, radius. or use FIND_UNITS_EVERYWHERE		DOTA_UNIT_TARGET_TEAM_FRIENDLY,	-- int, team filter		DOTA_UNIT_TARGET_HERO,	-- int, type filter		DOTA_UNIT_TARGET_FLAG_NONE, 	-- int, flag filter		0,	-- int, order filter		false	-- bool, can grow cache	)	for _,mate in pairs(teammates) do		mate:HealWithParams(caster:GetAttackDamage()*heal/100, self, false, true, caster, true)		mate:AddNewModifier(caster, self, "modifier_white_flower_buff", {duration = duration})		SendOverheadEventMessage(nil, OVERHEAD_ALERT_HEAL , mate, caster:GetAttackDamage()*heal/100, caster:GetPlayerOwner())	end	self:PlayEffects(location)endfunction item_white_flower:PlayEffects(location)	-- Get Resources	local particle_cast = "particles/units/heroes/hero_treant/treant_overgrowth_cast.vpcf"	local sound_cast = "Honkaiheroes.Skadi.Cast2"	-- -- Create Particle	local effect_cast = ParticleManager:CreateParticle( particle_cast, PATTACH_WORLDORIGIN, self:GetCaster() )	ParticleManager:SetParticleControl( effect_cast, 0, location )	ParticleManager:SetParticleControl( effect_cast, 60, Vector( 255,255,255) )	ParticleManager:SetParticleControl( effect_cast, 61, Vector( 255,255,255) )	ParticleManager:ReleaseParticleIndex( effect_cast )	-- Create Sound	EmitSoundOnLocationWithCaster( self:GetParent():GetOrigin(), sound_cast, self:GetCaster() )endmodifier_white_flower_buff = class({})function modifier_white_flower_buff:CheckState()	return{			[MODIFIER_STATE_MAGIC_IMMUNE ] = true		}endfunction modifier_white_flower_buff:GetEffectName()	return "particles/items_fx/black_king_bar_avatar.vpcf"endmodifier_white_flower_passive = class({})function modifier_white_flower_passive:IsHidden() return true endfunction modifier_white_flower_passive:DeclareFunctions()	return {MODIFIER_PROPERTY_COOLDOWN_PERCENTAGE }endfunction modifier_white_flower_passive:GetModifierPercentageCooldown(event)	if event.ability.GetAbilityType and event.ability:GetAbilityType() == 1 then return self:GetAbility():GetSpecialValueFor("cd_red") end	return 0end